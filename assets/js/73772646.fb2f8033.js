"use strict";(self.webpackChunkpeers_app_docs_hub=self.webpackChunkpeers_app_docs_hub||[]).push([[889],{7368:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"peers-sdk/injection8","title":"RPC Registry - Backward Compatibility Challenge","description":"The Problem with Global Exports","source":"@site/projects/peers-sdk/injection8.md","sourceDirName":"peers-sdk","slug":"/peers-sdk/injection8","permalink":"/peers-sdk/injection8","draft":false,"unlisted":false,"editUrl":"https://github.com/peers-app/peers-sdk/edit/main/docs/injection8.md","tags":[],"version":"current","frontMatter":{"custom_edit_url":"https://github.com/peers-app/peers-sdk/edit/main/docs/injection8.md"},"sidebar":"tutorialSidebar","previous":{"title":"RPC Registry Solution Plan","permalink":"/peers-sdk/injection7"},"next":{"title":"Peers Architecture","permalink":"/peers-sdk/user-group"}}');var i=n(4848),s=n(8453);const o={custom_edit_url:"https://github.com/peers-app/peers-sdk/edit/main/docs/injection8.md"},l="RPC Registry - Backward Compatibility Challenge",a={},c=[{value:"The Problem with Global Exports",id:"the-problem-with-global-exports",level:2},{value:"Potential Solutions",id:"potential-solutions",level:2},{value:"Option 1: Function Exports (Your Suggestion)",id:"option-1-function-exports-your-suggestion",level:3},{value:"Option 2: Proxy Objects with Late Binding",id:"option-2-proxy-objects-with-late-binding",level:3},{value:"Option 3: Registry on TableFactory (Minimal Client Changes)",id:"option-3-registry-on-tablefactory-minimal-client-changes",level:3},{value:"Option 4: Ambient RPC (Like Ambient DI)",id:"option-4-ambient-rpc-like-ambient-di",level:3},{value:"Recommendation: Option 2 (Proxy Objects)",id:"recommendation-option-2-proxy-objects",level:2}];function p(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"rpc-registry---backward-compatibility-challenge",children:"RPC Registry - Backward Compatibility Challenge"})}),"\n",(0,i.jsx)(t.h2,{id:"the-problem-with-global-exports",children:"The Problem with Global Exports"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"// This gets evaluated at module import time, before any injection\nexport const rpcServerCalls = getRPCServerCalls(); // \u274c Always uses default registry\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Issue:"})," By the time injection happens, existing code already has references to the default registry objects."]}),"\n",(0,i.jsx)(t.h2,{id:"potential-solutions",children:"Potential Solutions"}),"\n",(0,i.jsx)(t.h3,{id:"option-1-function-exports-your-suggestion",children:"Option 1: Function Exports (Your Suggestion)"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"// Change from object to function\nexport const rpcServerCalls = getRPCServerCalls; // Function, not invocation\n\n// All client code must change\nawait rpcServerCalls().tableGet(tableName, id); // \u274c Breaking change\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Pros:"})," Reliable resolution to injected state\n",(0,i.jsx)(t.strong,{children:"Cons:"})," Major breaking change for all RPC usage"]}),"\n",(0,i.jsx)(t.h3,{id:"option-2-proxy-objects-with-late-binding",children:"Option 2: Proxy Objects with Late Binding"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"// Create proxy that delegates to current registry\nexport const rpcServerCalls = new Proxy({}, {\n  get(target, prop) {\n    const registry = getCurrentRPCRegistry(); // Gets current injected registry\n    return registry.getServerCall(prop as string);\n  }\n});\n\n// Usage stays the same\nawait rpcServerCalls.tableGet(tableName, id); // \u2705 No breaking change\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Pros:"})," Zero breaking changes, reliable late binding\n",(0,i.jsx)(t.strong,{children:"Cons:"})," Slightly more complex, runtime overhead"]}),"\n",(0,i.jsx)(t.h3,{id:"option-3-registry-on-tablefactory-minimal-client-changes",children:"Option 3: Registry on TableFactory (Minimal Client Changes)"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"// Add RPC access to existing TableFactory pattern\nexport function getTableFactory() {\n  return {\n    getTable: ...,\n    rpcServerCalls: createRPCServerProxy(this.rpcRegistry),\n    rpcClientCalls: createRPCClientProxy(this.rpcRegistry)\n  };\n}\n\n// Client code updates minimally\nconst { rpcServerCalls } = getTableFactory();\nawait rpcServerCalls.tableGet(tableName, id);\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Pros:"})," Leverages existing injection pattern, minimal changes\n",(0,i.jsx)(t.strong,{children:"Cons:"})," Still requires some client code updates"]}),"\n",(0,i.jsx)(t.h3,{id:"option-4-ambient-rpc-like-ambient-di",children:"Option 4: Ambient RPC (Like Ambient DI)"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"let _globalRPCRegistry: RPCRegistry | undefined;\n\nexport function setGlobalRPCRegistry(registry: RPCRegistry): void {\n  _globalRPCRegistry = registry;\n  // Update the proxy targets\n  updateRPCProxies(registry);\n}\n\n// Existing exports use proxies that update when registry changes\nexport const rpcServerCalls = createUpdatableRPCProxy('server');\nexport const rpcClientCalls = createUpdatableRPCProxy('client');\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Pros:"})," Zero breaking changes, follows ambient DI pattern\n",(0,i.jsx)(t.strong,{children:"Cons:"})," Most complex implementation"]}),"\n",(0,i.jsx)(t.h2,{id:"recommendation-option-2-proxy-objects",children:"Recommendation: Option 2 (Proxy Objects)"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Why:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Zero breaking changes to client code"}),"\n",(0,i.jsx)(t.li,{children:"Reliable resolution to injected registry"}),"\n",(0,i.jsx)(t.li,{children:"Relatively simple implementation"}),"\n",(0,i.jsx)(t.li,{children:"Runtime overhead is minimal for RPC calls"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Implementation:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"function createRPCServerProxy(getRegistry: () => RPCRegistry) {\n  return new Proxy({} as any, {\n    get(target, prop: string) {\n      return getRegistry().getServerCall(prop);\n    }\n  });\n}\n\nexport const rpcServerCalls = createRPCServerProxy(() => getGlobalRPCRegistry());\n"})}),"\n",(0,i.jsx)(t.p,{children:"This preserves the existing API while ensuring RPC calls always resolve to the currently injected registry, even if injection happens after module import."})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>l});var r=n(6540);const i={},s=r.createContext(i);function o(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);