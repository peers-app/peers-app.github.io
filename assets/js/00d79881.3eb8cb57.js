"use strict";(self.webpackChunkpeers_app_docs_hub=self.webpackChunkpeers_app_docs_hub||[]).push([[646],{1010:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"peers-host/peer-device-download-chunk","title":"Peer Device File Chunk Download Specification","description":"Overview","source":"@site/projects/peers-host/peer-device-download-chunk.md","sourceDirName":"peers-host","slug":"/peers-host/peer-device-download-chunk","permalink":"/peers-host/peer-device-download-chunk","draft":false,"unlisted":false,"editUrl":"https://github.com/peers-app/peers-host/edit/main/peer-device-download-chunk.md","tags":[],"version":"current","frontMatter":{"custom_edit_url":"https://github.com/peers-app/peers-host/edit/main/peer-device-download-chunk.md"},"sidebar":"tutorialSidebar","previous":{"title":"claude","permalink":"/peers-host/claude"},"next":{"title":"Welcome to your Expo app \ud83d\udc4b","permalink":"/peers-react-native/"}}');var s=i(4848),l=i(8453);const t={custom_edit_url:"https://github.com/peers-app/peers-host/edit/main/peer-device-download-chunk.md"},o="Peer Device File Chunk Download Specification",a={},c=[{value:"Overview",id:"overview",level:2},{value:"Core Requirements",id:"core-requirements",level:2},{value:"Primary Methods",id:"primary-methods",level:3},{value:"<code>downloadFileChunk(chunkHash: string): Promise&lt;Buffer&gt;</code>",id:"downloadfilechunkchunkhash-string-promisebuffer",level:4},{value:"<code>getFileChunkInfo(chunkHash: string): Promise&lt;IFileChunkInfo&gt;</code>",id:"getfilechunkinfochunkhash-string-promiseifilechunkinfo",level:4},{value:"Architecture Design",id:"architecture-design",level:2},{value:"Request Pooling &amp; Deduplication",id:"request-pooling--deduplication",level:3},{value:"Peer Selection Strategy",id:"peer-selection-strategy",level:3},{value:"Concurrent Download Management",id:"concurrent-download-management",level:3},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Separate ChunkDownloadManager Class",id:"separate-chunkdownloadmanager-class",level:3},{value:"Remote Device Interface Extensions",id:"remote-device-interface-extensions",level:3},{value:"Error Handling &amp; Resilience",id:"error-handling--resilience",level:3},{value:"Performance Optimizations",id:"performance-optimizations",level:3},{value:"Network Protocol",id:"network-protocol",level:2},{value:"Chunk Availability Query",id:"chunk-availability-query",level:3},{value:"Chunk Download Request",id:"chunk-download-request",level:3},{value:"Integration with File System",id:"integration-with-file-system",level:2},{value:"Monitoring &amp; Observability",id:"monitoring--observability",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Future Enhancements",id:"future-enhancements",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"peer-device-file-chunk-download-specification",children:"Peer Device File Chunk Download Specification"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["This specification defines how the ",(0,s.jsx)(n.code,{children:"PeerDevice"})," class should implement efficient distributed file chunk downloading for the peers network. The system leverages the existing peer-to-peer architecture to download 1MB file chunks from optimal peer devices."]}),"\n",(0,s.jsx)(n.h2,{id:"core-requirements",children:"Core Requirements"}),"\n",(0,s.jsx)(n.h3,{id:"primary-methods",children:"Primary Methods"}),"\n",(0,s.jsx)(n.h4,{id:"downloadfilechunkchunkhash-string-promisebuffer",children:(0,s.jsx)(n.code,{children:"downloadFileChunk(chunkHash: string): Promise<Buffer>"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Downloads a single file chunk identified by its SHA-256 hash"}),"\n",(0,s.jsx)(n.li,{children:"Returns the raw chunk data as a Buffer"}),"\n",(0,s.jsx)(n.li,{children:"Implements automatic retry with exponential backoff"}),"\n",(0,s.jsx)(n.li,{children:"Verifies chunk integrity using SHA-256 hash validation"}),"\n",(0,s.jsx)(n.li,{children:"Pools requests to avoid duplicate downloads of the same chunk"}),"\n",(0,s.jsx)(n.li,{children:"Limits concurrent downloads to optimize network utilization"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"getfilechunkinfochunkhash-string-promiseifilechunkinfo",children:(0,s.jsx)(n.code,{children:"getFileChunkInfo(chunkHash: string): Promise<IFileChunkInfo>"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Retrieves metadata about chunk availability from a specific peer device"}),"\n",(0,s.jsx)(n.li,{children:"Returns information about whether the peer has the chunk and its current download queue status"}),"\n",(0,s.jsx)(n.li,{children:"Enables intelligent peer selection for optimal download performance"}),"\n",(0,s.jsxs)(n.li,{children:["Uses the standardized ",(0,s.jsx)(n.code,{children:"IFileChunkInfo"})," type from peers-sdk"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"architecture-design",children:"Architecture Design"}),"\n",(0,s.jsx)(n.h3,{id:"request-pooling--deduplication",children:"Request Pooling & Deduplication"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface ChunkDownloadPool {\n  activeDownloads: Map<string, Promise<Buffer>>;\n  downloadQueue: Map<string, ChunkDownloadRequest[]>;\n  concurrentLimit: number; // Default: 10\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Multiple requests for the same chunk return the same Promise"}),"\n",(0,s.jsx)(n.li,{children:"Prevents bandwidth waste from duplicate downloads"}),"\n",(0,s.jsx)(n.li,{children:"Batches requests when concurrent limit is reached"}),"\n",(0,s.jsx)(n.li,{children:"Provides back-pressure management for network resources"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"peer-selection-strategy",children:"Peer Selection Strategy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Using the actual IFileChunkInfo type from peers-sdk\ninterface ChunkAvailabilityInfo {\n  chunkHash: string;\n  availablePeers: Map<string, IFileChunkInfo & { \n    deviceId: string;\n    estimatedLatency: number;\n    errorRate: number;\n    lastSeen: number;\n  }>;\n  lastUpdated: number;\n  ttl: number; // Time-to-live in ms\n}\n\n// IFileChunkInfo is already defined in peers-sdk:\n// type IFileChunkInfo = \n//   { hasChunk: false } | \n//   { hasChunk: true; downloadQueueSize: number; estimatedWaitMs: number }\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Selection Algorithm:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Filter peers that have the chunk (",(0,s.jsx)(n.code,{children:"hasChunk: true"}),")"]}),"\n",(0,s.jsx)(n.li,{children:"Exclude peers with high error rates (>0.5)"}),"\n",(0,s.jsxs)(n.li,{children:["Sort by composite score: ",(0,s.jsx)(n.code,{children:"(downloadQueueSize + estimatedWaitMs) * estimatedLatency * (1 + errorRate)"})]}),"\n",(0,s.jsx)(n.li,{children:"Select the peer with the lowest score"}),"\n",(0,s.jsx)(n.li,{children:"Fallback to random selection if no optimal peer found"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"concurrent-download-management",children:"Concurrent Download Management"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Limits:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Maximum 10 concurrent chunk downloads"}),"\n",(0,s.jsx)(n.li,{children:"Maximum 3 downloads per peer device simultaneously"}),"\n",(0,s.jsx)(n.li,{children:"Queue additional requests when limits exceeded"}),"\n",(0,s.jsx)(n.li,{children:"Prioritize chunks for active file read streams"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Queue Management:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"FIFO queue for general chunk requests"}),"\n",(0,s.jsx)(n.li,{children:"Priority queue for urgent chunks (file read streams waiting)"}),"\n",(0,s.jsx)(n.li,{children:"Automatic cleanup of stale requests (>30 seconds old)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,s.jsx)(n.h3,{id:"separate-chunkdownloadmanager-class",children:"Separate ChunkDownloadManager Class"}),"\n",(0,s.jsxs)(n.p,{children:["To avoid bloating the existing ",(0,s.jsx)(n.code,{children:"PeerDevice"})," class, the chunk download functionality should be implemented in a dedicated ",(0,s.jsx)(n.code,{children:"ChunkDownloadManager"})," class:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"File Structure:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"src/\n  chunk-download-manager.ts  # Main implementation\n  chunk-download.types.ts    # Type definitions  \n  peer-device.ts            # Integration point\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Integration Approach:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// In peer-device.ts\nimport { ChunkDownloadManager } from './chunk-download-manager';\n\nclass PeerDevice implements IPeerDevice {\n  private chunkDownloadManager: ChunkDownloadManager;\n\n  constructor(/* existing params */) {\n    // existing constructor logic...\n    this.chunkDownloadManager = new ChunkDownloadManager(this);\n  }\n\n  // Delegate chunk download methods\n  public async downloadFileChunk(chunkHash: string): Promise<Buffer | null> {\n    return this.chunkDownloadManager.downloadChunk(chunkHash);\n  }\n\n  public async getFileChunkInfo(chunkHash: string): Promise<IFileChunkInfo> {\n    return this.chunkDownloadManager.getChunkInfo(chunkHash);\n  }\n}\n\n// In chunk-download-manager.ts\nexport class ChunkDownloadManager {\n  private chunkDownloadPool: ChunkDownloadPool;\n  private chunkInfoCache: Map<string, ChunkInfo>;\n  private downloadQueues: Map<string, number>;\n\n  constructor(private peerDevice: PeerDevice) {\n    this.initializeManager();\n  }\n\n  public async downloadChunk(chunkHash: string): Promise<Buffer | null> {\n    // Implementation here\n  }\n\n  public async getChunkInfo(chunkHash: string): Promise<IFileChunkInfo> {\n    // Implementation here  \n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"remote-device-interface-extensions",children:"Remote Device Interface Extensions"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"IPeerDevice"})," interface in peers-sdk now includes the required chunk methods:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface IPeerDevice {\n  // Existing methods...\n  listChanges(filter?: DataFilter<IChange>, opts?: IDataQueryParams<IChange>): Promise<IChange[]>;\n  getNetworkInfo(): Promise<INetworkInfo>;\n  notifyOfChanges(deviceId: string, timestampLastApplied: number): Promise<void>;\n  \n  // New chunk-related methods (already defined in peers-sdk)\n  downloadFileChunk(chunkHash: string): Promise<Buffer | null>;\n  getFileChunkInfo(chunkHash: string): Promise<IFileChunkInfo>;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"error-handling--resilience",children:"Error Handling & Resilience"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Retry Strategy:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Exponential backoff: 100ms, 200ms, 400ms, 800ms, 1.6s"}),"\n",(0,s.jsx)(n.li,{children:"Maximum 5 retry attempts per peer"}),"\n",(0,s.jsx)(n.li,{children:"Switch to different peer after 3 failed attempts"}),"\n",(0,s.jsx)(n.li,{children:"Circuit breaker pattern for consistently failing peers"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Integrity Verification:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Verify SHA-256 hash of downloaded chunks"}),"\n",(0,s.jsx)(n.li,{children:"Reject and retry chunks that fail verification"}),"\n",(0,s.jsx)(n.li,{children:"Track and report peers serving corrupt data"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Network Resilience:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Handle connection timeouts gracefully"}),"\n",(0,s.jsx)(n.li,{children:"Implement request cancellation for aborted operations"}),"\n",(0,s.jsx)(n.li,{children:"Maintain download progress for resumable operations"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"performance-optimizations",children:"Performance Optimizations"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Caching Strategy:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Cache ",(0,s.jsx)(n.code,{children:"ChunkInfo"})," for 60 seconds to reduce network queries"]}),"\n",(0,s.jsx)(n.li,{children:"LRU eviction when cache exceeds 1000 entries"}),"\n",(0,s.jsx)(n.li,{children:"Proactive cache warming for chunks likely to be requested"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Connection Reuse:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Leverage existing peer connections for chunk downloads"}),"\n",(0,s.jsx)(n.li,{children:"Multiplex multiple chunk requests over single connection"}),"\n",(0,s.jsx)(n.li,{children:"Implement HTTP/2-style request pipelining where possible"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Bandwidth Management:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Respect existing connection latency and error rate metrics"}),"\n",(0,s.jsx)(n.li,{children:"Throttle downloads on high-latency connections"}),"\n",(0,s.jsx)(n.li,{children:"Prioritize chunk downloads for interactive operations"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"network-protocol",children:"Network Protocol"}),"\n",(0,s.jsx)(n.h3,{id:"chunk-availability-query",children:"Chunk Availability Query"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Request: getFileChunkInfo\n{\n  method: 'getFileChunkInfo',\n  params: {\n    chunkHash: string\n  }\n}\n\n// Response using IFileChunkInfo type\n{\n  result: IFileChunkInfo // { hasChunk: false } | { hasChunk: true; downloadQueueSize: number; estimatedWaitMs: number }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"chunk-download-request",children:"Chunk Download Request"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Request: downloadFileChunk  \n{\n  method: 'downloadFileChunk',\n  params: {\n    chunkHash: string;\n    priority?: 'high' | 'normal' | 'low';\n  }\n}\n\n// Response\n{\n  result: Buffer | null; // Raw chunk data or null if not available\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"integration-with-file-system",children:"Integration with File System"}),"\n",(0,s.jsxs)(n.p,{children:["The chunk download system integrates with the existing file system via the ",(0,s.jsx)(n.code,{children:"FileOps"})," interface:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// In file-ops implementation\nconst fileOps: FileOps = {\n  downloadFileChunk: (chunkHash: string) => peerDevice.downloadFileChunk(chunkHash),\n  // ... other methods\n};\n\nsetFileOps(fileOps);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This allows the existing ",(0,s.jsx)(n.code,{children:"FileReadStream"})," to transparently download chunks from peers when they're not available locally."]}),"\n",(0,s.jsx)(n.h2,{id:"monitoring--observability",children:"Monitoring & Observability"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Metrics to Track:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Chunks downloaded per peer"}),"\n",(0,s.jsx)(n.li,{children:"Average download latency per peer"}),"\n",(0,s.jsx)(n.li,{children:"Chunk download success/failure rates"}),"\n",(0,s.jsx)(n.li,{children:"Pool queue depth over time"}),"\n",(0,s.jsx)(n.li,{children:"Cache hit/miss ratios"}),"\n",(0,s.jsx)(n.li,{children:"Bandwidth utilization per peer"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Logging:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Debug logs for chunk requests and peer selection"}),"\n",(0,s.jsx)(n.li,{children:"Warn logs for failed downloads and retries"}),"\n",(0,s.jsx)(n.li,{children:"Error logs for chunks that can't be downloaded from any peer"}),"\n",(0,s.jsx)(n.li,{children:"Performance logs for unusually slow downloads"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Tunable Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MAX_CONCURRENT_DOWNLOADS"}),": Default 10"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MAX_DOWNLOADS_PER_PEER"}),": Default 3"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CHUNK_INFO_CACHE_TTL"}),": Default 60 seconds"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DOWNLOAD_TIMEOUT"}),": Default 30 seconds"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MAX_RETRY_ATTEMPTS"}),": Default 5"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"RETRY_BACKOFF_BASE"}),": Default 100ms"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"future-enhancements",children:"Future Enhancements"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Priority-Based Downloads:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"High priority for chunks blocking file read operations"}),"\n",(0,s.jsx)(n.li,{children:"Normal priority for prefetch operations"}),"\n",(0,s.jsx)(n.li,{children:"Low priority for background sync operations"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Predictive Prefetching:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Monitor file access patterns"}),"\n",(0,s.jsx)(n.li,{children:"Preload likely-needed chunks in background"}),"\n",(0,s.jsx)(n.li,{children:"Integrate with file system read-ahead logic"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Peer Reputation System:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Track long-term peer reliability"}),"\n",(0,s.jsx)(n.li,{children:"Prefer peers with history of successful downloads"}),"\n",(0,s.jsx)(n.li,{children:"Implement peer scoring based on multiple factors"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Bandwidth Optimization:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Compress chunks during transport (if beneficial)"}),"\n",(0,s.jsx)(n.li,{children:"Implement chunk bundling for small chunks"}),"\n",(0,s.jsx)(n.li,{children:"Support partial chunk downloads for seeking operations"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>o});var r=i(6540);const s={},l=r.createContext(s);function t(e){const n=r.useContext(l);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);