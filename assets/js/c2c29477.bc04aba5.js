"use strict";(self.webpackChunkpeers_app_docs_hub=self.webpackChunkpeers_app_docs_hub||[]).push([[54],{1185:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"peers-sdk/injection","title":"Simple Isomorphic DI System for peers-sdk","description":"Current Problems","source":"@site/projects/peers-sdk/injection.md","sourceDirName":"peers-sdk","slug":"/peers-sdk/injection","permalink":"/peers-sdk/injection","draft":false,"unlisted":false,"editUrl":"https://github.com/peers-app/peers-sdk/edit/main/docs/injection.md","tags":[],"version":"current","frontMatter":{"custom_edit_url":"https://github.com/peers-app/peers-sdk/edit/main/docs/injection.md"},"sidebar":"tutorialSidebar","previous":{"title":"Peers Device Architecture","permalink":"/peers-sdk/devices"},"next":{"title":"Maintaining Ergonomics with DI","permalink":"/peers-sdk/injection2"}}');var s=t(4848),i=t(8453);const a={custom_edit_url:"https://github.com/peers-app/peers-sdk/edit/main/docs/injection.md"},o="Simple Isomorphic DI System for peers-sdk",c={},l=[{value:"Current Problems",id:"current-problems",level:2},{value:"Recommended DI Architecture",id:"recommended-di-architecture",level:2},{value:"Core DI Container",id:"core-di-container",level:3},{value:"Injectable Decorator",id:"injectable-decorator",level:3},{value:"Refactored Table System",id:"refactored-table-system",level:3},{value:"Container Setup",id:"container-setup",level:3},{value:"Integration Pattern",id:"integration-pattern",level:3},{value:"Migration Strategy",id:"migration-strategy",level:2},{value:"Phase 1: Add DI Infrastructure",id:"phase-1-add-di-infrastructure",level:3},{value:"Phase 2: Refactor Core Services",id:"phase-2-refactor-core-services",level:3},{value:"Phase 3: Update Data Access Patterns",id:"phase-3-update-data-access-patterns",level:3},{value:"Phase 4: Remove Globals",id:"phase-4-remove-globals",level:3},{value:"Benefits",id:"benefits",level:2},{value:"Key Design Decisions",id:"key-design-decisions",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"simple-isomorphic-di-system-for-peers-sdk",children:"Simple Isomorphic DI System for peers-sdk"})}),"\n",(0,s.jsx)(n.h2,{id:"current-problems",children:"Current Problems"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Module instantiation coupling"}),": Functions like ",(0,s.jsx)(n.code,{children:"Messages()"}),", ",(0,s.jsx)(n.code,{children:"PersistentVars()"})," are immediately dependent on ",(0,s.jsx)(n.code,{children:"getTableFactory()"})," being set"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Global singleton state"}),": ",(0,s.jsx)(n.code,{children:"_tableFactory"})," creates tight coupling and prevents multiple instances"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cross-package conflicts"}),": When peers-ui, peers-electron, etc. all import peers-sdk, they create separate instances but fight over the same global state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Timing dependencies"}),": Tables and persistentVars are instantiated at module import time, making dependency injection impossible"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"recommended-di-architecture",children:"Recommended DI Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"core-di-container",children:"Core DI Container"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/di/container.ts\ntype Constructor<T = any> = new (...args: any[]) => T;\ntype Factory<T = any> = (...args: any[]) => T;\ntype Token = string | symbol | Constructor;\n\nexport class DIContainer {\n  private instances = new Map<Token, any>();\n  private factories = new Map<Token, Factory | Constructor>();\n  private singletons = new Set<Token>();\n\n  register<T>(token: Token, factory: Factory<T> | Constructor<T>, singleton = true): void {\n    this.factories.set(token, factory);\n    if (singleton) this.singletons.add(token);\n  }\n\n  resolve<T>(token: Token): T {\n    if (this.instances.has(token)) {\n      return this.instances.get(token);\n    }\n\n    const factory = this.factories.get(token);\n    if (!factory) {\n      throw new Error(`No factory registered for token: ${String(token)}`);\n    }\n\n    const instance = typeof factory === 'function' && factory.prototype \n      ? new (factory as Constructor<T>)(...this.resolveDependencies(factory))\n      : (factory as Factory<T>)(...this.resolveDependencies(factory));\n\n    if (this.singletons.has(token)) {\n      this.instances.set(token, instance);\n    }\n\n    return instance;\n  }\n\n  private resolveDependencies(target: any): any[] {\n    return (target.inject || []).map((dep: Token) => this.resolve(dep));\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"injectable-decorator",children:"Injectable Decorator"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/di/injectable.ts\nexport function Injectable(...deps: Token[]) {\n  return function <T extends Constructor>(target: T) {\n    (target as any).inject = deps;\n    return target;\n  };\n}\n\nexport const TOKENS = {\n  DataSourceFactory: Symbol('DataSourceFactory'),\n  TableFactory: Symbol('TableFactory'),\n  Container: Symbol('Container'),\n} as const;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"refactored-table-system",children:"Refactored Table System"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/data/orm/table-factory.ts (refactored)\n@Injectable(TOKENS.DataSourceFactory)\nexport class TableFactory {\n  constructor(private dataSourceFactory: DataSourceFactory) {}\n  // ... existing implementation\n}\n\n// src/data/messages.ts (refactored)\nexport function createMessagesAccessor(container: DIContainer) {\n  return () => container.resolve<TableFactory>(TOKENS.TableFactory)\n    .getTable<IMessage>(metaData, messageSchema);\n}\n\n// Usage: const Messages = createMessagesAccessor(container);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"container-setup",children:"Container Setup"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/di/setup.ts\nexport function createContainer(dataSourceFactory?: DataSourceFactory): DIContainer {\n  const container = new DIContainer();\n  \n  // Register core services\n  container.register(TOKENS.DataSourceFactory, dataSourceFactory || defaultDataSourceFactory);\n  container.register(TOKENS.TableFactory, TableFactory);\n  \n  return container;\n}\n\nexport function createDefaultClientContainer(): DIContainer {\n  return createContainer(() => new ClientProxyDataSource());\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"integration-pattern",children:"Integration Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// In consuming packages (peers-ui, peers-electron, etc.)\nimport { createDefaultClientContainer, TOKENS } from 'peers-sdk/di';\n\nexport class PeersUI {\n  private container: DIContainer;\n  \n  constructor(container?: DIContainer) {\n    this.container = container || createDefaultClientContainer();\n  }\n  \n  get messages() {\n    return this.container.resolve<TableFactory>(TOKENS.TableFactory)\n      .getTable(messageMetaData, messageSchema);\n  }\n}\n\n// Usage:\nconst sharedContainer = createDefaultClientContainer();\nconst ui = new PeersUI(sharedContainer);\nconst electron = new PeersElectron(sharedContainer);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"migration-strategy",children:"Migration Strategy"}),"\n",(0,s.jsx)(n.h3,{id:"phase-1-add-di-infrastructure",children:"Phase 1: Add DI Infrastructure"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Create DI container and injectable decorator"}),"\n",(0,s.jsx)(n.li,{children:"Add container setup utilities"}),"\n",(0,s.jsx)(n.li,{children:"Keep existing global functions working"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-2-refactor-core-services",children:"Phase 2: Refactor Core Services"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Convert TableFactory to use DI"}),"\n",(0,s.jsx)(n.li,{children:"Update table creation to accept container"}),"\n",(0,s.jsx)(n.li,{children:"Maintain backward compatibility"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-3-update-data-access-patterns",children:"Phase 3: Update Data Access Patterns"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Replace ",(0,s.jsx)(n.code,{children:"Messages()"})," with ",(0,s.jsx)(n.code,{children:"container.resolve(Messages)"})]}),"\n",(0,s.jsx)(n.li,{children:"Convert persistentVar to accept container"}),"\n",(0,s.jsx)(n.li,{children:"Update consuming packages"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-4-remove-globals",children:"Phase 4: Remove Globals"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Remove global ",(0,s.jsx)(n.code,{children:"_tableFactory"})]}),"\n",(0,s.jsxs)(n.li,{children:["Remove ",(0,s.jsx)(n.code,{children:"getTableFactory()"})," and ",(0,s.jsx)(n.code,{children:"setTableFactory()"})]}),"\n",(0,s.jsx)(n.li,{children:"Complete migration"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"benefits",children:"Benefits"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"True isolation"}),": Each package instance gets its own dependency graph"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Testability"}),": Easy to inject mocks and test dependencies"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Flexibility"}),": Different environments can configure different data sources"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Isomorphic"}),": Works in browser, React Native, and Node.js"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type safety"}),": Full TypeScript support with proper typing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Minimal complexity"}),": Simple container without reflection dependencies"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Backward compatibility"}),": Gradual migration path"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"key-design-decisions",children:"Key Design Decisions"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No reflect-metadata"}),": Explicit dependency declaration for React Native compatibility"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Constructor injection only"}),": Simpler than property injection"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Token-based"}),": Supports interfaces and abstract types"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Singleton by default"}),": Matches current behavior for tables"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Container passing"}),": Explicit container passing instead of global lookup"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Factory functions"}),": For tables that need specific instantiation logic"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This approach solves the module instantiation problem by making dependencies explicit and injectable, while maintaining the simplicity and isomorphic nature required for peers-sdk."})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);