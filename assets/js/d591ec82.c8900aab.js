"use strict";(self.webpackChunkpeers_app_docs_hub=self.webpackChunkpeers_app_docs_hub||[]).push([[177],{8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(6540);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}},8522:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"peers-sdk/claude","title":"claude","description":"Here\u2019s a summary of our discussions on Dependency Injection (DI) and a guide for implementing your own simple DI library with decorators, without requiring reflect-metadata.","source":"@site/projects/peers-sdk/claude.md","sourceDirName":"peers-sdk","slug":"/peers-sdk/claude","permalink":"/peers-sdk/claude","draft":false,"unlisted":false,"editUrl":"https://github.com/peers-app/peers-sdk/edit/main/docs/claude.md","tags":[],"version":"current","frontMatter":{"custom_edit_url":"https://github.com/peers-app/peers-sdk/edit/main/docs/claude.md"},"sidebar":"tutorialSidebar","previous":{"title":"peers-sdk","permalink":"/peers-sdk/"},"next":{"title":"claude2","permalink":"/peers-sdk/claude2"}}');var s=t(4848),o=t(8453);const i={custom_edit_url:"https://github.com/peers-app/peers-sdk/edit/main/docs/claude.md"},a=void 0,c={},d=[];function l(e){const n={code:"code",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Here\u2019s a summary of our discussions on Dependency Injection (DI) and a guide for implementing your own simple DI library with decorators, without requiring reflect-metadata."}),"\n",(0,s.jsx)(n.p,{children:"\u2e3b"}),"\n",(0,s.jsx)(n.p,{children:"\ud83e\udde0 Summary of DI Discussions\n\u2022\tYou\u2019ve mostly avoided formal DI up to this point, managing dependencies manually.\n\u2022\tYou\u2019re now facing enough complexity that a centralized DI system feels necessary.\n\u2022\tYou\u2019re interested in decorators for ergonomics but want to avoid reflect-metadata due to:\n\u2022\tCompatibility concerns, especially with React Native.\n\u2022\tThe need for tight control over behavior and minimal dependencies.\n\u2022\tYou considered libraries like:\n\u2022\tNestJS DI: Powerful but tightly coupled to reflect-metadata and complex.\n\u2022\ttsyringe: Decorator-based and simpler, but also requires reflect-metadata.\n\u2022\tYou\u2019re leaning toward building your own simple DI system, tailored for your use case."}),"\n",(0,s.jsx)(n.p,{children:"\u2e3b"}),"\n",(0,s.jsx)(n.p,{children:"\u2699\ufe0f Instructions to Build a Simple DI Library with Decorators (No reflect-metadata)"}),"\n",(0,s.jsx)(n.p,{children:"Step 1: Define a basic container"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type Constructor<T = any> = new (...args: any[]) => T;\n\nclass Container {\n  private singletons = new Map<string | symbol | Constructor, any>();\n  private providers = new Map<string | symbol | Constructor, Constructor>();\n\n  register<T>(token: string | symbol | Constructor<T>, provider: Constructor<T>) {\n    this.providers.set(token, provider);\n  }\n\n  resolve<T>(token: string | symbol | Constructor<T>): T {\n    if (this.singletons.has(token)) {\n      return this.singletons.get(token);\n    }\n\n    const provider = this.providers.get(token);\n    if (!provider) throw new Error(`No provider found for token: ${token.toString()}`);\n\n    // Manual injection via static `inject` property\n    const deps = (provider as any).inject?.map((dep: any) => this.resolve(dep)) ?? [];\n    const instance = new provider(...deps);\n    this.singletons.set(token, instance);\n    return instance;\n  }\n}\n\nexport const container = new Container();\n"})}),"\n",(0,s.jsx)(n.p,{children:"\u2e3b"}),"\n",(0,s.jsx)(n.p,{children:"Step 2: Create decorators"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export function Injectable(...deps: any[]) {\n  return function <T extends Constructor>(target: T) {\n    (target as any).inject = deps;\n    container.register(target, target);\n  };\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Usage:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'@Injectable()\nclass Logger {\n  log(msg: string) {\n    console.log(msg);\n  }\n}\n\n@Injectable(Logger)\nclass Service {\n  constructor(private logger: Logger) {}\n  doSomething() {\n    this.logger.log("Service did something");\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"\u2e3b"}),"\n",(0,s.jsx)(n.p,{children:"Step 3: Resolve and use"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const service = container.resolve(Service);\nservice.doSomething();\n"})}),"\n",(0,s.jsx)(n.p,{children:"\u2e3b"}),"\n",(0,s.jsx)(n.p,{children:"\u2705 Advantages\n\u2022\tNo reflect-metadata needed.\n\u2022\tWorks in browsers and React Native.\n\u2022\tClear, explicit dependencies.\n\u2022\tEasy to extend (e.g., for scoped instances or factories)."}),"\n",(0,s.jsx)(n.p,{children:"\u26a0\ufe0f Limitations\n\u2022\tYou must declare dependencies manually via @Injectable(...).\n\u2022\tNo property injection (constructor-only).\n\u2022\tNo circular dependency support (without extra logic)."}),"\n",(0,s.jsx)(n.p,{children:"Instructions to Claude: improve on the discussion above.  Write out your own recommendations for how we can implement a very simple and isomorphic DI library for peers-sdk.\nI think the main things that need DI are tables and some kind of factory or container for the persistentVars.  The most trouble is coming from them being instantiated when the module is imported.  This makes it so we can't control when they are instantiated so multiple instances of the peers-sdk library produce multiple instances of the instantiations."}),"\n",(0,s.jsx)(n.p,{children:"What we want is a single top-level DI container that we can inject into downstream dependencies (like peers-ui, peers-electron, peers-react-native, peers-device, etc) and it's okay if they all are using their own instance of the peers-sdk because that is just types and static code.  The state will all be shared (if needed) by one dependency's main file instantiating the DI container and injecting that into the rest of the upstream dependencies."}),"\n",(0,s.jsx)(n.p,{children:"Write out your thoughts and recommendations to injection.md.  Keep it simple and concise."})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);