love it—let’s keep everything TypeScript + Markdown and still use the hub‑and‑spokes model. The cleanest fit is Docusaurus: it’s Node/TS‑native, reads Markdown/MDX, and supports per‑page edit links via custom_edit_url in front‑matter (perfect for pointing back to each source repo).

Below is a ready setup for an org hub repo: peers-app.github.io (hub) that aggregates /docs from selected repos (spokes) using a tiny TypeScript script and a GitHub Actions workflow.

⸻

1) Create the hub repo

peers-app.github.io (public)

peers-app.github.io/
  package.json
  tsconfig.json
  docusaurus.config.ts
  sidebars.ts
  scripts/
    aggregate.ts
  src/
    pages/
      index.md
  projects/            # filled by aggregate.ts (do not edit by hand)

package.json

{
  "name": "peers-app-docs-hub",
  "private": true,
  "scripts": {
    "aggregate": "tsx scripts/aggregate.ts",
    "build": "docusaurus build",
    "start": "docusaurus start",
    "deploy": "docusaurus deploy"
  },
  "dependencies": {
    "@docusaurus/core": "^3.5.2",
    "@docusaurus/preset-classic": "^3.5.2",
    "fs-extra": "^11.2.0",
    "globby": "^14.0.2",
    "gray-matter": "^4.0.3"
  },
  "devDependencies": {
    "tsx": "^4.16.2",
    "typescript": "^5.5.4"
  }
}

tsconfig.json

{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "esModuleInterop": true,
    "strict": true,
    "types": ["node"]
  }
}

docusaurus.config.ts

import type { Config } from '@docusaurus/types';
import { themes as prismThemes } from 'prism-react-renderer';

const config: Config = {
  title: 'Peers App Docs',
  url: 'https://peers-app.github.io',
  baseUrl: '/',
  favicon: 'img/favicon.ico',
  organizationName: 'peers-app', // GitHub org
  projectName: 'peers-app.github.io', // repo
  deploymentBranch: 'gh-pages',

  presets: [
    [
      'classic',
      {
        docs: {
          path: 'projects',             // we build aggregated docs into /projects
          routeBasePath: '/',           // docs at site root
          sidebarPath: require.resolve('./sidebars.ts'),
          editUrl: undefined            // we’ll use per-page custom_edit_url instead
        },
        theme: { customCss: [] }
      }
    ]
  ],

  themeConfig: {
    navbar: {
      title: 'Peers App',
      items: [
        { to: '/', label: 'Docs', position: 'left' },
        { href: 'https://github.com/peers-app', label: 'GitHub', position: 'right' }
      ]
    },
    prism: {
      theme: prismThemes.github,
      darkTheme: prismThemes.dracula
    }
  }
};

export default config;

sidebars.ts

import type { SidebarsConfig } from '@docusaurus/plugin-content-docs';

const sidebars: SidebarsConfig = {
  // Docusaurus will auto-generate sidebar from filesystem
  // (one big tree under /projects). You can split by folders later if you like.
  tutorialSidebar: [{ type: 'autogenerated', dirName: '.' }]
};

export default sidebars;

src/pages/index.md

# Peers App Docs

Welcome to the Peers documentation hub.

- **Projects**
  - [peers-host](/peers-host/)
  - [peers-logic](/peers-logic/)

> Tip: Every page has an **Edit this page** link that goes to the correct source repo/path.


⸻

2) Add the TS aggregator

This script copies /docs from selected repos into projects/<repo>/ and injects front‑matter with custom_edit_url so Docusaurus shows a correct Edit this page link.

scripts/aggregate.ts

import fse from 'fs-extra';
import { globby } from 'globby';
import matter from 'gray-matter';
import path from 'node:path';

type RepoSpec = {
  repo: string;           // "peers-app/peers-host"
  local: string;          // where actions/checkout placed it: "_sources/peers-host"
  docsDir?: string;       // default "docs"
  branch?: string;        // default "main"
};

const REPOS: RepoSpec[] = [
  { repo: 'peers-app/peers-host',  local: '_sources/peers-host',  docsDir: 'docs', branch: 'main' },
  { repo: 'peers-app/peers-logic', local: '_sources/peers-logic', docsDir: 'docs', branch: 'main' }
];

const OUT_ROOT = 'projects';

async function run() {
  await fse.emptyDir(OUT_ROOT);

  for (const r of REPOS) {
    const srcDocs = path.join(r.local, r.docsDir ?? 'docs');
    const out = path.join(OUT_ROOT, r.repo.split('/')[1]);

    if (!fse.existsSync(srcDocs)) {
      console.warn(`[skip] ${r.repo} has no ${srcDocs}`);
      continue;
    }

    await fse.copy(srcDocs, out);

    // inject custom_edit_url into every .md/.mdx
    const files = await globby(['**/*.md', '**/*.mdx'], { cwd: out });
    for (const rel of files) {
      const abs = path.join(out, rel);
      const raw = await fse.readFile(abs, 'utf-8');
      const fm = matter(raw);

      const custom = `https://github.com/${r.repo}/edit/${r.branch ?? 'main'}/${path.posix.join(r.docsDir ?? 'docs', rel).replace(/\\/g, '/')}`;

      const data = {
        // preserve existing front-matter
        ...fm.data,
        custom_edit_url: fm.data?.custom_edit_url ?? custom
      };

      await fse.writeFile(abs, matter.stringify(fm.content.trimStart() + '\n', data));
    }

    // add an index if missing
    const indexCandidates = ['index.md', 'README.md'];
    const hasIndex = indexCandidates.some(n => fse.existsSync(path.join(out, n)));
    if (!hasIndex) {
      await fse.writeFile(
        path.join(out, 'index.md'),
        matter.stringify(
          `# ${r.repo.split('/')[1]}\n\nProject docs aggregated from \`${r.repo}\`.\n`,
          { custom_edit_url: `https://github.com/${r.repo}` }
        )
      );
    }
  }

  console.log('Aggregation complete.');
}

run().catch(err => {
  console.error(err);
  process.exit(1);
});


⸻

3) GitHub Actions (TypeScript‑friendly)

This workflow checks out the hub and the source repos, runs the TS aggregator with tsx, builds the site with Docusaurus, and deploys to gh-pages.

.github/workflows/deploy.yml

name: Build & Deploy (TS Hub)

on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout hub
        uses: actions/checkout@v4

      - name: Checkout peers-host
        uses: actions/checkout@v4
        with:
          repository: peers-app/peers-host
          path: _sources/peers-host

      - name: Checkout peers-logic
        uses: actions/checkout@v4
        with:
          repository: peers-app/peers-logic
          path: _sources/peers-logic

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Install deps
        run: npm ci

      - name: Aggregate docs (TS)
        run: npm run aggregate

      - name: Build site
        run: npm run build

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./build
          publish_branch: gh-pages

Add/remove repos by editing REPOS in scripts/aggregate.ts and mirroring checkout steps in the workflow.

⸻

4) Authoring flow in each project repo

Keep docs next to code:

peers-host/
  docs/
    index.md
    guides/...
    reference/...

No Python needed; just Markdown. If a page already has front‑matter, leave it—our aggregator merges and adds custom_edit_url only if missing.

⸻

5) Render inside Peers (Electron & RN)

Build once, reuse everywhere.
	•	The hub emits a static site in /build. Add a CI artifact or separate build in peers-docs if you want, but simplest is to clone the same site output into your app bundles.

Electron (main):

import { app, BrowserWindow } from 'electron';
import { join } from 'node:path';

app.whenReady().then(() => {
  const win = new BrowserWindow({ width: 1280, height: 860 });
  win.loadFile(join(process.resourcesPath, 'docs/index.html')); // copy build/* → resources/docs
});

React Native (Expo):

import { WebView } from 'react-native-webview';

export default function DocsScreen() {
  // place the /build folder into the app bundle (Android assets / iOS main bundle)
  return <WebView source={{ uri: 'file:///android_asset/docs/index.html' }} />;
}

If your router relies on history API, serve locally (RN: react-native-static-server; Electron: tiny express.static) and loadURL('http://127.0.0.1:PORT').

⸻

6) Why this stays TypeScript‑native
	•	Build tooling: Node + Docusaurus + TS configs.
	•	Aggregation: tiny TypeScript script.
	•	CI: Node toolchain only.
	•	Authoring: Markdown (and MDX if/when you want interactive snippets).

⸻

If you give me the exact first two repos to aggregate (sounds like peers-host and peers-logic), I’ll tailor the REPOS array + landing page and tweak the workflow to your org conventions.